# 实现图片切割功能计划

## 1. HTML结构修改

### 1.1 添加切割功能区域
在下载区域下方添加一个新的区域，用于处理图片切割功能：
- 新增拖放区域，用于接收待切割的PNG文件
- 添加切割结果预览区域
- 添加打包下载按钮

### 1.2 具体修改
```html
<!-- 切割功能区域 -->
<section class="cut-section" id="cutSection" style="display: none;">
    <h2 class="section-title">图片切割</h2>
    
    <!-- 拖放区域 -->
    <div class="drop-container" id="cutDropContainer">
        <div class="drop-content">
            <svg class="drop-icon" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7 10 12 15 17 10"></polyline>
                <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
            <h2 class="drop-title">拖放PNG文件到此处进行切割</h2>
            <p class="drop-hint">请确保图片比例与原始拼接图一致</p>
            <p class="drop-subhint">或</p>
            <button class="btn-secondary" id="cutBrowseBtn">浏览文件</button>
            <input type="file" id="cutFileInput" accept=".png" multiple style="display: none;">
        </div>
    </div>
    
    <!-- 切割结果下载 -->
    <div class="cut-result" id="cutResult" style="display: none;">
        <h3 class="cut-result-title">切割结果</h3>
        <button class="btn-primary" id="downloadCutBtn">打包下载切割图</button>
    </div>
</section>
```

## 2. JavaScript功能实现

### 2.1 全局变量
```javascript
// 切割功能相关变量
let cutFiles = [];
let cutImages = [];
let cutResultImages = [];
let cutCanvas = null;
```

### 2.2 初始化函数
```javascript
/**
 * 初始化切割功能
 */
function initCutFunctionality() {
    // 初始化切割拖放区域
    initCutDragAndDrop();
    
    // 初始化切割浏览文件功能
    initCutBrowseFiles();
    
    // 初始化切割下载按钮
    initCutDownloadButtons();
    
    // 初始化切割Canvas
    cutCanvas = document.createElement('canvas');
}
```

### 2.3 拖放功能
```javascript
/**
 * 初始化切割拖放功能
 */
function initCutDragAndDrop() {
    const cutDropContainer = document.getElementById('cutDropContainer');
    const cutFileInput = document.getElementById('cutFileInput');
    
    // 拖放事件处理
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        cutDropContainer.addEventListener(eventName, preventDefaults, false);
    });
    
    // 高亮效果
    ['dragenter', 'dragover'].forEach(eventName => {
        cutDropContainer.addEventListener(eventName, cutHighlight, false);
    });
    
    ['dragleave', 'drop'].forEach(eventName => {
        cutDropContainer.addEventListener(eventName, cutUnhighlight, false);
    });
    
    // 处理放置的文件
    cutDropContainer.addEventListener('drop', handleCutDrop, false);
    
    // 点击拖放区域也可以选择文件
    cutDropContainer.addEventListener('click', function() {
        cutFileInput.click();
    });
}
```

### 2.4 文件处理
```javascript
/**
 * 处理切割用的文件
 */
function handleCutFiles(files) {
    // 过滤出PNG文件
    const pngFiles = files.filter(file => file.type === 'image/png');
    
    if (pngFiles.length === 0) {
        showToast('请选择PNG文件');
        return;
    }
    
    cutFiles = pngFiles;
    loadCutImages(pngFiles);
}
```

### 2.5 图片处理和切割
```javascript
/**
 * 处理切割图片
 */
function processCutImage() {
    if (cutImages.length === 0 || positionData.length === 0) return;
    
    const cutImage = cutImages[0].image;
    const originalWidth = positionData.canvasSize.width;
    const originalHeight = positionData.canvasSize.height;
    
    // 验证比例是否一致
    const cutRatio = cutImage.width / cutImage.height;
    const originalRatio = originalWidth / originalHeight;
    
    if (Math.abs(cutRatio - originalRatio) > 0.01) {
        showToast('图片比例与原始拼接图不一致');
        return;
    }
    
    // 扣除底色
    const processedImage = removeBackground(cutImage);
    
    // 缩放图片到原始拼接图大小
    const scaledCanvas = scaleImage(processedImage, originalWidth, originalHeight);
    
    // 按照位置信息切割图片
    cutImagesByPosition(scaledCanvas);
    
    // 显示切割结果
    showCutResult();
    
    showToast('图片切割完成');
}

/**
 * 扣除底色
 */
function removeBackground(image) {
    // 创建临时Canvas
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = image.width;
    tempCanvas.height = image.height;
    
    // 绘制图片
    tempCtx.drawImage(image, 0, 0);
    
    // 获取ImageData
    const imageData = tempCtx.getImageData(0, 0, image.width, image.height);
    const data = imageData.data;
    
    // 简单的底色扣除逻辑（可根据实际需求调整）
    // 这里假设底色是白色，将接近白色的像素设为透明
    for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        
        // 如果是接近白色的像素，设为透明
        if (r > 240 && g > 240 && b > 240) {
            data[i + 3] = 0;
        }
    }
    
    // 将处理后的ImageData放回Canvas
    tempCtx.putImageData(imageData, 0, 0);
    
    // 创建新图片
    const resultImage = new Image();
    resultImage.src = tempCanvas.toDataURL();
    return resultImage;
}

/**
 * 缩放图片
 */
function scaleImage(image, targetWidth, targetHeight) {
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = targetWidth;
    tempCanvas.height = targetHeight;
    
    // 绘制并缩放图片
    tempCtx.drawImage(image, 0, 0, targetWidth, targetHeight);
    
    return tempCanvas;
}

/**
 * 按照位置信息切割图片
 */
function cutImagesByPosition(canvas) {
    const ctx = canvas.getContext('2d');
    cutResultImages = [];
    
    // 遍历位置信息，切割图片
    positionData.images.forEach((item, index) => {
        // 创建切割Canvas
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = item.size.width;
        tempCanvas.height = item.size.height;
        
        // 切割图片
        tempCtx.drawImage(
            canvas, 
            item.position.x, item.position.y, 
            item.size.width, item.size.height, 
            0, 0, 
            item.size.width, item.size.height
        );
        
        // 保存切割结果
        cutResultImages.push({
            filename: item.filename,
            canvas: tempCanvas
        });
    });
}
```

### 2.6 打包下载功能
```javascript
/**
 * 初始化切割下载按钮
 */
function initCutDownloadButtons() {
    const downloadCutBtn = document.getElementById('downloadCutBtn');
    
    downloadCutBtn.addEventListener('click', function() {
        downloadCutImages();
    });
}

/**
 * 下载切割后的图片
 */
function downloadCutImages() {
    if (cutResultImages.length === 0) return;
    
    // 创建一个临时链接，逐个下载图片
    // 注意：由于浏览器限制，无法直接打包成ZIP，这里使用逐个下载的方式
    cutResultImages.forEach((item, index) => {
        downloadCanvasAsImage(item.canvas, item.filename);
    });
    
    showToast(`已开始下载 ${cutResultImages.length} 张切割图`);
}
```

## 3. CSS样式调整

### 3.1 添加切割功能样式
```css
/* 切割功能区域 */
.cut-section {
    background-color: var(--bg-elevated);
    border: 1px solid var(--border-base);
    border-radius: var(--radius-lg);
    padding: var(--space-6);
    margin-top: var(--space-8);
    transition: background-color var(--transition-slow);
}

.cut-result {
    margin-top: var(--space-6);
    padding: var(--space-4);
    background-color: var(--bg-base);
    border: 1px solid var(--border-light);
    border-radius: var(--radius-md);
}

.cut-result-title {
    font-size: var(--font-size-md);
    font-weight: var(--font-weight-medium);
    color: var(--text-primary);
    margin-bottom: var(--space-4);
}
```

## 4. 集成到现有代码

### 4.1 在initApp函数中添加初始化
```javascript
function initApp() {
    // 现有初始化代码...
    
    // 初始化切割功能
    initCutFunctionality();
}
```

### 4.2 在showPreviewAndDownload函数中显示切割区域
```javascript
function showPreviewAndDownload() {
    // 现有代码...
    
    // 显示切割功能区域
    const cutSection = document.getElementById('cutSection');
    cutSection.style.display = 'block';
}
```

## 5. 功能流程图

1. 用户拖入多张PNG文件，生成拼接图、Alpha通道图和位置信息
2. 系统显示预览和下载区域，并显示切割功能区域
3. 用户拖入待切割的PNG文件
4. 系统验证文件类型和比例
5. 系统处理图片：扣除底色 -> 缩放到原始大小 -> 按照位置信息切割
6. 系统显示切割结果和下载按钮
7. 用户点击下载按钮，系统下载所有切割后的图片

## 6. 注意事项

1. 由于浏览器限制，无法直接将多张图片打包成ZIP文件，这里使用逐个下载的方式
2. 底色扣除逻辑使用了简单的白色检测，可根据实际需求调整
3. 比例验证允许1%的误差，避免因像素四舍五入导致的问题
4. 切割功能仅在生成了位置信息后才可用

这个实现计划将为拼图工具添加完整的图片切割功能，保持与现有设计风格一致，并提供良好的用户体验。