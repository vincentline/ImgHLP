"use strict";(this.webpackChunkPuzzleTool=this.webpackChunkPuzzleTool||[]).push([["src_sdk_index_js"],{"./src/core/cut.js"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cutImagesByPosition: () => (/* binding */ cutImagesByPosition),\n/* harmony export */   processCutImage: () => (/* binding */ processCutImage),\n/* harmony export */   removeBackground: () => (/* binding */ removeBackground),\n/* harmony export */   scaleImage: () => (/* binding */ scaleImage)\n/* harmony export */ });\nfunction _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a \'" + o + "\' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }\nfunction _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }\n/**\n * 图片切割模块\n * 负责将拼图切割成多张原始图片\n */\n\n/**\n * 扣除底色\n * @param {HTMLImageElement} image - 图片元素\n * @returns {HTMLCanvasElement} - 处理后的Canvas\n */\nfunction removeBackground(image) {\n  // 创建临时Canvas\n  var tempCanvas = document.createElement(\'canvas\');\n  var tempCtx = tempCanvas.getContext(\'2d\');\n  tempCanvas.width = image.width;\n  tempCanvas.height = image.height;\n\n  // 绘制图片\n  tempCtx.drawImage(image, 0, 0);\n\n  // 获取ImageData\n  var imageData = tempCtx.getImageData(0, 0, image.width, image.height);\n  var data = imageData.data;\n\n  // 简单的底色扣除逻辑\n  // 将接近白色的像素设为透明\n  for (var i = 0; i < data.length; i += 4) {\n    var r = data[i];\n    var g = data[i + 1];\n    var b = data[i + 2];\n\n    // 如果是接近白色的像素，设为透明\n    if (r > 240 && g > 240 && b > 240) {\n      data[i + 3] = 0;\n    }\n  }\n\n  // 将处理后的ImageData放回Canvas\n  tempCtx.putImageData(imageData, 0, 0);\n  return tempCanvas;\n}\n\n/**\n * 缩放图片\n * @param {HTMLCanvasElement} canvas - Canvas元素\n * @param {number} targetWidth - 目标宽度\n * @param {number} targetHeight - 目标高度\n * @returns {HTMLCanvasElement} - 缩放后的Canvas\n */\nfunction scaleImage(canvas, targetWidth, targetHeight) {\n  var tempCanvas = document.createElement(\'canvas\');\n  var tempCtx = tempCanvas.getContext(\'2d\');\n  tempCanvas.width = targetWidth;\n  tempCanvas.height = targetHeight;\n\n  // 绘制并缩放图片\n  tempCtx.drawImage(canvas, 0, 0, targetWidth, targetHeight);\n  return tempCanvas;\n}\n\n/**\n * 按照位置信息切割图片\n * @param {HTMLCanvasElement} canvas - 拼图Canvas\n * @param {Object} positionData - 位置信息\n * @returns {Array} - 切割后的图片数组，每个元素包含filename和canvas\n */\nfunction cutImagesByPosition(canvas, positionData) {\n  var ctx = canvas.getContext(\'2d\');\n  var cutResultImages = [];\n\n  // 遍历位置信息，切割图片\n  positionData.images.forEach(function (item) {\n    // 创建切割Canvas\n    var tempCanvas = document.createElement(\'canvas\');\n    var tempCtx = tempCanvas.getContext(\'2d\');\n    tempCanvas.width = item.size.width;\n    tempCanvas.height = item.size.height;\n\n    // 切割图片\n    tempCtx.drawImage(canvas, item.position.x, item.position.y, item.size.width, item.size.height, 0, 0, item.size.width, item.size.height);\n\n    // 保存切割结果\n    cutResultImages.push({\n      filename: item.filename,\n      canvas: tempCanvas\n    });\n  });\n  return cutResultImages;\n}\n\n/**\n * 处理切割图片\n * @param {HTMLImageElement} cutImage - 要切割的图片\n * @param {Object} positionData - 位置信息\n * @returns {Promise<Array>} - 切割后的图片数组\n */\nfunction processCutImage(_x, _x2) {\n  return _processCutImage.apply(this, arguments);\n}\nfunction _processCutImage() {\n  _processCutImage = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(cutImage, positionData) {\n    var originalWidth, originalHeight, cutRatio, originalRatio, processedCanvas, scaledCanvas, cutImages;\n    return _regenerator().w(function (_context) {\n      while (1) switch (_context.n) {\n        case 0:\n          if (!(!positionData || !positionData.canvasSize)) {\n            _context.n = 1;\n            break;\n          }\n          throw new Error(\'Position data is required\');\n        case 1:\n          originalWidth = positionData.canvasSize.width;\n          originalHeight = positionData.canvasSize.height; // 验证比例是否一致\n          cutRatio = cutImage.width / cutImage.height;\n          originalRatio = originalWidth / originalHeight;\n          if (!(Math.abs(cutRatio - originalRatio) > 0.01)) {\n            _context.n = 2;\n            break;\n          }\n          throw new Error(\'Image ratio does not match original\');\n        case 2:\n          // 扣除底色（返回Canvas）\n          processedCanvas = removeBackground(cutImage); // 缩放图片到原始拼接图大小\n          scaledCanvas = scaleImage(processedCanvas, originalWidth, originalHeight); // 按照位置信息切割图片\n          cutImages = cutImagesByPosition(scaledCanvas, positionData);\n          return _context.a(2, cutImages);\n      }\n    }, _callee);\n  }));\n  return _processCutImage.apply(this, arguments);\n}\n\n//# sourceURL=webpack://PuzzleTool/./src/core/cut.js?\n}')},"./src/core/image.js"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canvasToBlob: () => (/* binding */ canvasToBlob),\n/* harmony export */   generateAlphaImage: () => (/* binding */ generateAlphaImage),\n/* harmony export */   generatePositionData: () => (/* binding */ generatePositionData),\n/* harmony export */   generateResultImage: () => (/* binding */ generateResultImage),\n/* harmony export */   loadImage: () => (/* binding */ loadImage)\n/* harmony export */ });\n/**\n * 图片处理模块\n * 负责生成拼图、Alpha通道图和位置信息\n */\n\n/**\n * 生成拼接图\n * @param {number} width - 画布宽度\n * @param {number} height - 画布高度\n * @param {Array} layout - 布局信息数组\n * @returns {HTMLCanvasElement} - 拼接图Canvas\n */\nfunction generateResultImage(width, height, layout) {\n  var canvas = document.createElement('canvas');\n  var ctx = canvas.getContext('2d');\n\n  // 设置Canvas尺寸\n  canvas.width = width;\n  canvas.height = height;\n\n  // 清空Canvas\n  ctx.clearRect(0, 0, width, height);\n\n  // 填充透明背景\n  ctx.fillStyle = 'rgba(0, 0, 0, 0)';\n  ctx.fillRect(0, 0, width, height);\n\n  // 绘制每张图片\n  layout.forEach(function (item) {\n    ctx.drawImage(item.image.image, item.x, item.y, item.width, item.height);\n  });\n  return canvas;\n}\n\n/**\n * 生成Alpha通道图\n * @param {number} width - 画布宽度\n * @param {number} height - 画布高度\n * @param {Array} layout - 布局信息数组\n * @returns {HTMLCanvasElement} - Alpha通道图Canvas\n */\nfunction generateAlphaImage(width, height, layout) {\n  var canvas = document.createElement('canvas');\n  var ctx = canvas.getContext('2d');\n\n  // 设置Canvas尺寸\n  canvas.width = width;\n  canvas.height = height;\n\n  // 清空Canvas，填充黑色背景\n  ctx.fillStyle = '#000000';\n  ctx.fillRect(0, 0, width, height);\n\n  // 绘制每张图片的Alpha通道\n  layout.forEach(function (item) {\n    var img = item.image.image;\n\n    // 创建临时Canvas来处理Alpha通道\n    var tempCanvas = document.createElement('canvas');\n    var tempCtx = tempCanvas.getContext('2d');\n    tempCanvas.width = img.width;\n    tempCanvas.height = img.height;\n\n    // 绘制原始图片到临时Canvas\n    tempCtx.drawImage(img, 0, 0);\n\n    // 获取ImageData\n    var imageData = tempCtx.getImageData(0, 0, img.width, img.height);\n    var data = imageData.data;\n\n    // 处理Alpha通道：不透明部分转为白色，透明部分保持黑色\n    for (var i = 0; i < data.length; i += 4) {\n      var alpha = data[i + 3];\n      if (alpha > 0) {\n        // 不透明部分：白色\n        data[i] = 255; // R\n        data[i + 1] = 255; // G\n        data[i + 2] = 255; // B\n        data[i + 3] = 255; // A\n      } else {\n        // 透明部分：黑色\n        data[i] = 0; // R\n        data[i + 1] = 0; // G\n        data[i + 2] = 0; // B\n        data[i + 3] = 255; // A\n      }\n    }\n\n    // 将处理后的ImageData放回临时Canvas\n    tempCtx.putImageData(imageData, 0, 0);\n\n    // 将临时Canvas绘制到AlphaCanvas\n    ctx.drawImage(tempCanvas, item.x, item.y, item.width, item.height);\n  });\n  return canvas;\n}\n\n/**\n * 生成位置信息\n * @param {number} width - 画布宽度\n * @param {number} height - 画布高度\n * @param {Array} layout - 布局信息数组\n * @returns {Object} - 位置信息对象\n */\nfunction generatePositionData(width, height, layout) {\n  return {\n    canvasSize: {\n      width: width,\n      height: height\n    },\n    images: layout.map(function (item) {\n      return {\n        filename: item.image.name,\n        position: {\n          x: item.x,\n          y: item.y\n        },\n        size: {\n          width: item.width,\n          height: item.height\n        },\n        // 相对坐标（0-1范围），便于AI理解\n        relativePosition: {\n          x: item.x / width,\n          y: item.y / height\n        },\n        relativeSize: {\n          width: item.width / width,\n          height: item.height / height\n        }\n      };\n    })\n  };\n}\n\n/**\n * Canvas转Blob\n * @param {HTMLCanvasElement} canvas - Canvas元素\n * @param {string} type - 图片类型\n * @param {number} quality - 图片质量\n * @returns {Promise<Blob>} - Blob对象\n */\nfunction canvasToBlob(canvas) {\n  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'image/png';\n  var quality = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  return new Promise(function (resolve, reject) {\n    canvas.toBlob(function (blob) {\n      if (blob) {\n        resolve(blob);\n      } else {\n        reject(new Error('Canvas to blob failed'));\n      }\n    }, type, quality);\n  });\n}\n\n/**\n * 加载图片\n * @param {File|Blob|string} imageSource - 图片源（File、Blob或DataURL）\n * @returns {Promise<HTMLImageElement>} - 加载完成的Image元素\n */\nfunction loadImage(imageSource) {\n  return new Promise(function (resolve, reject) {\n    var img = new Image();\n    img.onload = function () {\n      return resolve(img);\n    };\n    img.onerror = function () {\n      return reject(new Error('Image load failed'));\n    };\n    if (imageSource instanceof File || imageSource instanceof Blob) {\n      var reader = new FileReader();\n      reader.onload = function (e) {\n        img.src = e.target.result;\n      };\n      reader.onerror = function () {\n        return reject(new Error('File read failed'));\n      };\n      reader.readAsDataURL(imageSource);\n    } else {\n      img.src = imageSource;\n    }\n  });\n}\n\n//# sourceURL=webpack://PuzzleTool/./src/core/image.js?\n}")},"./src/core/layout.js"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateBestLayout: () => (/* binding */ calculateBestLayout)\n/* harmony export */ });\n/**\n * 布局计算模块\n * 负责计算最佳拼图布局\n */\n\n/**\n * 计算最佳拼图布局\n * @param {Array} images - 图片数组，每个元素包含image对象\n * @returns {Object} - 包含width、height和layout的对象\n */\nfunction calculateBestLayout(images) {\n  // 计算所有图片的最大宽度\n  var margin = 10; // 图片间距\n\n  // 首先计算图片在网格排列下的实际尺寸\n  var actualWidth = 0;\n  var actualHeight = 0;\n  var currentX = margin;\n  var currentY = margin;\n  var rowHeight = 0;\n\n  // 计算实际需要的宽度和高度（使用足够大的临时宽度）\n  images.forEach(function (img) {\n    var image = img.image;\n\n    // 单行排列所有图片，计算实际需要的最大宽度\n    currentX += image.width + margin;\n    rowHeight = Math.max(rowHeight, image.height);\n\n    // 记录最大宽度\n    if (currentX > actualWidth) {\n      actualWidth = currentX;\n    }\n  });\n\n  // 计算单行排列的高度\n  actualHeight = currentY + rowHeight;\n\n  // 减去最后一个图片的右侧间距\n  actualWidth -= margin;\n\n  // 现在重新计算网格排列的实际尺寸\n  // 尝试找到最佳的列数，使宽度和高度更加合理\n  var optimalCols = 1;\n  var optimalGridWidth = actualWidth;\n  var optimalGridHeight = actualHeight;\n  var minEmptySpace = Infinity;\n\n  // 尝试不同的列数，找到最佳排列\n  var _loop = function _loop(cols) {\n    var gridWidth = 0;\n    var gridHeight = margin;\n    var rowX = margin;\n    var rowMaxHeight = 0;\n    images.forEach(function (img, index) {\n      var image = img.image;\n\n      // 换行逻辑\n      if (index > 0 && index % cols === 0) {\n        gridWidth = Math.max(gridWidth, rowX - margin);\n        gridHeight += rowMaxHeight + margin;\n        rowX = margin;\n        rowMaxHeight = 0;\n      }\n      rowX += image.width + margin;\n      rowMaxHeight = Math.max(rowMaxHeight, image.height);\n    });\n\n    // 处理最后一行\n    gridWidth = Math.max(gridWidth, rowX - margin);\n    gridHeight += rowMaxHeight;\n\n    // 计算当前排列的空白空间\n    var totalArea = gridWidth * gridHeight;\n    var totalImageArea = images.reduce(function (sum, img) {\n      return sum + img.image.width * img.image.height;\n    }, 0);\n    var emptySpace = totalArea - totalImageArea;\n\n    // 找到空白空间最小的排列\n    if (emptySpace < minEmptySpace) {\n      minEmptySpace = emptySpace;\n      optimalCols = cols;\n      optimalGridWidth = gridWidth;\n      optimalGridHeight = gridHeight;\n    }\n  };\n  for (var cols = 1; cols <= images.length; cols++) {\n    _loop(cols);\n  }\n\n  // 对于两张图片的特殊情况，优先选择水平排列\n  if (images.length === 2) {\n    var horizontalWidth = images[0].image.width + images[1].image.width + margin * 3;\n    var horizontalHeight = Math.max(images[0].image.height, images[1].image.height) + margin * 2;\n    var horizontalArea = horizontalWidth * horizontalHeight;\n    var horizontalEmptySpace = horizontalArea - (images[0].image.width * images[0].image.height + images[1].image.width * images[1].image.height);\n    var verticalWidth = Math.max(images[0].image.width, images[1].image.width) + margin * 2;\n    var verticalHeight = images[0].image.height + images[1].image.height + margin * 3;\n    var verticalArea = verticalWidth * verticalHeight;\n    var verticalEmptySpace = verticalArea - (images[0].image.width * images[0].image.height + images[1].image.width * images[1].image.height);\n\n    // 如果水平排列的空白空间不大于垂直排列的空白空间，选择水平排列\n    if (horizontalEmptySpace <= verticalEmptySpace) {\n      optimalCols = 2;\n      optimalGridWidth = horizontalWidth - margin;\n      optimalGridHeight = horizontalHeight - margin;\n    }\n  }\n\n  // 基于最佳网格尺寸，计算符合1:1、4:3或16:9比例的尺寸\n  var aspectRatios = [{\n    width: 1,\n    height: 1,\n    name: '1:1'\n  }, {\n    width: 4,\n    height: 3,\n    name: '4:3'\n  }, {\n    width: 16,\n    height: 9,\n    name: '16:9'\n  }];\n\n  // 找出最适合的比例和尺寸\n  var bestRatio = null;\n  var bestWidth = 0;\n  var bestHeight = 0;\n  var minArea = Infinity;\n\n  // 计算每种比例下的最佳尺寸\n  aspectRatios.forEach(function (ratio) {\n    // 计算基于实际尺寸的比例适配\n    var width, height;\n\n    // 两种方式计算，选择较小的面积\n    // 方式1：基于宽度适配\n    width = Math.ceil(optimalGridWidth);\n    height = Math.ceil(width * ratio.height / ratio.width);\n\n    // 确保高度足够\n    if (height < optimalGridHeight) {\n      height = Math.ceil(optimalGridHeight);\n      width = Math.ceil(height * ratio.width / ratio.height);\n    }\n\n    // 计算面积\n    var area1 = width * height;\n\n    // 方式2：基于高度适配\n    height = Math.ceil(optimalGridHeight);\n    width = Math.ceil(height * ratio.width / ratio.height);\n\n    // 确保宽度足够\n    if (width < optimalGridWidth) {\n      width = Math.ceil(optimalGridWidth);\n      height = Math.ceil(width * ratio.height / ratio.width);\n    }\n\n    // 计算面积\n    var area2 = width * height;\n\n    // 选择较小的面积\n    var area = Math.min(area1, area2);\n\n    // 选择面积最小的比例\n    if (area < minArea) {\n      minArea = area;\n      bestRatio = ratio;\n      bestWidth = area === area1 ? Math.ceil(optimalGridWidth) : Math.ceil(height * ratio.width / ratio.height);\n      bestHeight = Math.ceil(bestWidth * ratio.height / ratio.width);\n    }\n  });\n\n  // 确保生成的尺寸严格符合比例\n  // 重新计算，确保精确符合比例\n  bestWidth = Math.ceil(bestWidth / bestRatio.width) * bestRatio.width;\n  bestHeight = Math.ceil(bestWidth * bestRatio.height / bestRatio.width);\n\n  // 确保尺寸足够容纳所有图片\n  if (bestWidth < optimalGridWidth) {\n    bestWidth = Math.ceil(optimalGridWidth / bestRatio.width) * bestRatio.width;\n    bestHeight = Math.ceil(bestWidth * bestRatio.height / bestRatio.width);\n  }\n  if (bestHeight < optimalGridHeight) {\n    bestHeight = Math.ceil(optimalGridHeight / bestRatio.height) * bestRatio.height;\n    bestWidth = Math.ceil(bestHeight * bestRatio.width / bestRatio.height);\n  }\n\n  // 限制最大尺寸不超过4096\n  var maxSize = 4096;\n  if (bestWidth > maxSize || bestHeight > maxSize) {\n    // 计算缩放比例\n    var scale = Math.min(maxSize / bestWidth, maxSize / bestHeight);\n\n    // 按比例缩小宽度和高度，确保符合比例\n    bestWidth = Math.ceil(bestWidth * scale / bestRatio.width) * bestRatio.width;\n    bestHeight = Math.ceil(bestWidth * bestRatio.height / bestRatio.width);\n\n    // 确保缩小后的尺寸仍能容纳所有图片\n    // 如果缩小后无法容纳，需要重新调整列数和排列方式\n    // 这里简化处理，确保最小尺寸至少容纳单张图片\n    var minRequiredWidth = images.reduce(function (max, img) {\n      return Math.max(max, img.image.width);\n    }, 0) + margin * 2;\n    var minRequiredHeight = images.reduce(function (max, img) {\n      return Math.max(max, img.image.height);\n    }, 0) + margin * 2;\n    bestWidth = Math.max(bestWidth, minRequiredWidth);\n    bestHeight = Math.max(bestHeight, minRequiredHeight);\n\n    // 确保最终严格符合比例\n    bestHeight = Math.ceil(bestWidth * bestRatio.height / bestRatio.width);\n  }\n\n  // 确保bestWidth至少等于optimalGridWidth，以容纳所有图片\n  if (bestWidth < optimalGridWidth) {\n    bestWidth = Math.ceil(optimalGridWidth / bestRatio.width) * bestRatio.width;\n    bestHeight = Math.ceil(bestWidth * bestRatio.height / bestRatio.width);\n  }\n\n  // 确保bestHeight至少等于optimalGridHeight，以容纳所有图片\n  if (bestHeight < optimalGridHeight) {\n    bestHeight = Math.ceil(optimalGridHeight / bestRatio.height) * bestRatio.height;\n    bestWidth = Math.ceil(bestHeight * bestRatio.width / bestRatio.height);\n  }\n\n  // 最终确保严格符合比例\n  bestHeight = Math.ceil(bestWidth * bestRatio.height / bestRatio.width);\n\n  // 计算最终的网格排列位置\n  var layout = [];\n  currentX = margin;\n  currentY = margin;\n  rowHeight = 0;\n  var itemsPerRow = 0;\n\n  // 对于两张图片的特殊情况，强制设置为水平排列\n  if (images.length === 2) {\n    itemsPerRow = 2;\n  } else {\n    // 计算最佳每行显示数量\n    for (var i = 1; i <= images.length; i++) {\n      var testWidth = images.slice(0, i).reduce(function (sum, img) {\n        return sum + img.image.width;\n      }, 0) + margin * (i + 1);\n      if (testWidth <= bestWidth) {\n        itemsPerRow = i;\n      } else {\n        break;\n      }\n    }\n  }\n\n  // 重新排列图片\n  images.forEach(function (img, index) {\n    var image = img.image;\n\n    // 换行逻辑\n    if (index > 0 && index % itemsPerRow === 0) {\n      currentY += rowHeight + margin;\n      currentX = margin;\n      rowHeight = 0;\n    }\n\n    // 记录位置\n    layout.push({\n      image: img,\n      x: currentX,\n      y: currentY,\n      width: image.width,\n      height: image.height\n    });\n\n    // 更新当前行信息\n    currentX += image.width + margin;\n    rowHeight = Math.max(rowHeight, image.height);\n  });\n  return {\n    width: bestWidth,\n    height: bestHeight,\n    layout: layout\n  };\n}\n\n//# sourceURL=webpack://PuzzleTool/./src/core/layout.js?\n}")},"./src/core/utils.js"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deepClone: () => (/* binding */ deepClone),\n/* harmony export */   formatError: () => (/* binding */ formatError),\n/* harmony export */   generateId: () => (/* binding */ generateId),\n/* harmony export */   isValidImageSource: () => (/* binding */ isValidImageSource),\n/* harmony export */   isValidPositionData: () => (/* binding */ isValidPositionData),\n/* harmony export */   wait: () => (/* binding */ wait)\n/* harmony export */ });\n/**\n * 工具函数模块\n * 提供各种辅助功能\n */\n\n/**\n * 生成唯一ID\n * @returns {string} - 唯一ID\n */\nfunction generateId() {\n  return Date.now().toString(36) + Math.random().toString(36).substr(2);\n}\n\n/**\n * 深拷贝对象\n * @param {Object} obj - 要拷贝的对象\n * @returns {Object} - 拷贝后的对象\n */\nfunction deepClone(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\n/**\n * 验证图片源是否有效\n * @param {*} imageSource - 图片源\n * @returns {boolean} - 是否有效\n */\nfunction isValidImageSource(imageSource) {\n  return imageSource instanceof File || imageSource instanceof Blob || typeof imageSource === 'string' && imageSource.startsWith('data:image/');\n}\n\n/**\n * 验证位置信息是否有效\n * @param {Object} positionData - 位置信息\n * @returns {boolean} - 是否有效\n */\nfunction isValidPositionData(positionData) {\n  return positionData && positionData.canvasSize && typeof positionData.canvasSize.width === 'number' && typeof positionData.canvasSize.height === 'number' && Array.isArray(positionData.images) && positionData.images.length > 0;\n}\n\n/**\n * 格式化错误信息\n * @param {Error} error - 错误对象\n * @returns {string} - 格式化后的错误信息\n */\nfunction formatError(error) {\n  return error.message || 'Unknown error';\n}\n\n/**\n * 等待指定时间\n * @param {number} ms - 等待时间（毫秒）\n * @returns {Promise} - 等待完成的Promise\n */\nfunction wait(ms) {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, ms);\n  });\n}\n\n//# sourceURL=webpack://PuzzleTool/./src/core/utils.js?\n}")},"./src/sdk/index.js"(module,__webpack_exports__,__webpack_require__){eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PuzzleToolSDK: () => (/* binding */ PuzzleToolSDK),\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _core_layout_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/layout.js */ "./src/core/layout.js");\n/* harmony import */ var _core_image_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/image.js */ "./src/core/image.js");\n/* harmony import */ var _core_cut_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/cut.js */ "./src/core/cut.js");\n/* harmony import */ var _core_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/utils.js */ "./src/core/utils.js");\n/* module decorator */ module = __webpack_require__.hmd(module);\nfunction _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a \'" + o + "\' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }\nfunction _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }\nfunction _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }\n/**\n * 拼图工具SDK\n * 提供拼图和切割功能的JavaScript SDK\n */\n\n\n\n\n\n\n/**\n * 拼图工具SDK\n */\nvar PuzzleToolSDK = {\n  /**\n   * 合并多张图片为拼图\n   * @param {Array} images - 图片源数组（File、Blob或DataURL）\n   * @returns {Promise<Object>} - 包含拼图、Alpha图和位置信息的对象\n   */\n  merge: function merge(images) {\n    return _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {\n      var _iterator, _step, imageSource, loadedImages, _calculateBestLayout, width, height, layout, resultCanvas, resultBlob, alphaCanvas, alphaBlob, positionData, _t, _t2;\n      return _regenerator().w(function (_context2) {\n        while (1) switch (_context2.p = _context2.n) {\n          case 0:\n            _context2.p = 0;\n            if (!(!Array.isArray(images) || images.length === 0)) {\n              _context2.n = 1;\n              break;\n            }\n            throw new Error(\'Images array is required and must not be empty\');\n          case 1:\n            // 验证每张图片\n            _iterator = _createForOfIteratorHelper(images);\n            _context2.p = 2;\n            _iterator.s();\n          case 3:\n            if ((_step = _iterator.n()).done) {\n              _context2.n = 5;\n              break;\n            }\n            imageSource = _step.value;\n            if ((0,_core_utils_js__WEBPACK_IMPORTED_MODULE_3__.isValidImageSource)(imageSource)) {\n              _context2.n = 4;\n              break;\n            }\n            throw new Error(\'Invalid image source\');\n          case 4:\n            _context2.n = 3;\n            break;\n          case 5:\n            _context2.n = 7;\n            break;\n          case 6:\n            _context2.p = 6;\n            _t = _context2.v;\n            _iterator.e(_t);\n          case 7:\n            _context2.p = 7;\n            _iterator.f();\n            return _context2.f(7);\n          case 8:\n            _context2.n = 9;\n            return Promise.all(images.map(/*#__PURE__*/function () {\n              var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(imageSource, index) {\n                var img;\n                return _regenerator().w(function (_context) {\n                  while (1) switch (_context.n) {\n                    case 0:\n                      _context.n = 1;\n                      return (0,_core_image_js__WEBPACK_IMPORTED_MODULE_1__.loadImage)(imageSource);\n                    case 1:\n                      img = _context.v;\n                      return _context.a(2, {\n                        file: imageSource instanceof File ? imageSource : null,\n                        image: img,\n                        name: imageSource instanceof File ? imageSource.name : "image_".concat(index, ".png")\n                      });\n                  }\n                }, _callee);\n              }));\n              return function (_x, _x2) {\n                return _ref.apply(this, arguments);\n              };\n            }()));\n          case 9:\n            loadedImages = _context2.v;\n            // 计算最佳布局\n            _calculateBestLayout = (0,_core_layout_js__WEBPACK_IMPORTED_MODULE_0__.calculateBestLayout)(loadedImages), width = _calculateBestLayout.width, height = _calculateBestLayout.height, layout = _calculateBestLayout.layout; // 生成拼图\n            resultCanvas = (0,_core_image_js__WEBPACK_IMPORTED_MODULE_1__.generateResultImage)(width, height, layout);\n            _context2.n = 10;\n            return (0,_core_image_js__WEBPACK_IMPORTED_MODULE_1__.canvasToBlob)(resultCanvas);\n          case 10:\n            resultBlob = _context2.v;\n            // 生成Alpha通道图\n            alphaCanvas = (0,_core_image_js__WEBPACK_IMPORTED_MODULE_1__.generateAlphaImage)(width, height, layout);\n            _context2.n = 11;\n            return (0,_core_image_js__WEBPACK_IMPORTED_MODULE_1__.canvasToBlob)(alphaCanvas);\n          case 11:\n            alphaBlob = _context2.v;\n            // 生成位置信息\n            positionData = (0,_core_image_js__WEBPACK_IMPORTED_MODULE_1__.generatePositionData)(width, height, layout); // 返回结果\n            return _context2.a(2, {\n              mergedImage: resultBlob,\n              alphaImage: alphaBlob,\n              positionData: positionData\n            });\n          case 12:\n            _context2.p = 12;\n            _t2 = _context2.v;\n            throw new Error("Merge failed: ".concat((0,_core_utils_js__WEBPACK_IMPORTED_MODULE_3__.formatError)(_t2)));\n          case 13:\n            return _context2.a(2);\n        }\n      }, _callee2, null, [[2, 6, 7, 8], [0, 12]]);\n    }))();\n  },\n  /**\n   * 切割拼图为多张原始图片\n   * @param {File|Blob|string} mergedImage - 拼图图片\n   * @param {File|Blob|string} alphaImage - Alpha通道图（可选）\n   * @param {Object} positionData - 位置信息\n   * @returns {Promise<Array>} - 切割后的图片数组\n   */\n  split: function split(mergedImage, positionData) {\n    return _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4() {\n      var img, cutImages, cutBlobs, _t3;\n      return _regenerator().w(function (_context4) {\n        while (1) switch (_context4.p = _context4.n) {\n          case 0:\n            _context4.p = 0;\n            if ((0,_core_utils_js__WEBPACK_IMPORTED_MODULE_3__.isValidImageSource)(mergedImage)) {\n              _context4.n = 1;\n              break;\n            }\n            throw new Error(\'Invalid merged image source\');\n          case 1:\n            if ((0,_core_utils_js__WEBPACK_IMPORTED_MODULE_3__.isValidPositionData)(positionData)) {\n              _context4.n = 2;\n              break;\n            }\n            throw new Error(\'Invalid position data\');\n          case 2:\n            _context4.n = 3;\n            return (0,_core_image_js__WEBPACK_IMPORTED_MODULE_1__.loadImage)(mergedImage);\n          case 3:\n            img = _context4.v;\n            _context4.n = 4;\n            return (0,_core_cut_js__WEBPACK_IMPORTED_MODULE_2__.processCutImage)(img, positionData);\n          case 4:\n            cutImages = _context4.v;\n            _context4.n = 5;\n            return Promise.all(cutImages.map(/*#__PURE__*/function () {\n              var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(item) {\n                var blob;\n                return _regenerator().w(function (_context3) {\n                  while (1) switch (_context3.n) {\n                    case 0:\n                      _context3.n = 1;\n                      return (0,_core_image_js__WEBPACK_IMPORTED_MODULE_1__.canvasToBlob)(item.canvas);\n                    case 1:\n                      blob = _context3.v;\n                      return _context3.a(2, {\n                        filename: item.filename,\n                        image: blob\n                      });\n                  }\n                }, _callee3);\n              }));\n              return function (_x3) {\n                return _ref2.apply(this, arguments);\n              };\n            }()));\n          case 5:\n            cutBlobs = _context4.v;\n            return _context4.a(2, cutBlobs);\n          case 6:\n            _context4.p = 6;\n            _t3 = _context4.v;\n            throw new Error("Split failed: ".concat((0,_core_utils_js__WEBPACK_IMPORTED_MODULE_3__.formatError)(_t3)));\n          case 7:\n            return _context4.a(2);\n        }\n      }, _callee4, null, [[0, 6]]);\n    }))();\n  }\n};\n\n// 导出SDK\nif ( true && module.exports) {\n  // CommonJS\n  module.exports = PuzzleToolSDK;\n} else if (typeof window !== \'undefined\') {\n  // 浏览器全局变量\n  window.PuzzleTool = PuzzleToolSDK;\n} else if (typeof self !== \'undefined\') {\n  // Web Worker\n  self.PuzzleTool = PuzzleToolSDK;\n}\n\n// ES模块导出\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PuzzleToolSDK);\n\n\n//# sourceURL=webpack://PuzzleTool/./src/sdk/index.js?\n}')}}]);